### 1. 前言

1. 系统与磁盘间IO的交互基本单位为 块 `4KB` ，即 8 * 扇区 `512B` 。

2. 磁盘的`连续访问`效率总是高于`随机访问`，因为`随机访问`需要额外的进行定位和寻找数据块的过程。

3. MySQL与磁盘间IO的交互基本单位为 页`16KB`(Page)，因为它有着更高的IO场景 。（以`InnoDB`为例）
4. MySQL 的 `CURD` 操作 ，均需要将数据移动到`内存`当中，在内存中对数据进行操作，再以特定的刷新策略，与磁盘进行IO。 
5. 为了更好的进行上面的操作， MySQL 服务器在内存中运行的时候，服务器内部就申请了被称为 `Buffer Pool` 的的大内存空间，用来进行各种缓存。  
6. 以上均是为了减少系统和磁盘IO的次数 ，来提高IO效率 



### 2. 索引介绍

索引是一种数据结构，用于快速定位到数据库表中的特定行或列。

- 在一方面，索引可以通过减少需要扫描的数据行数来提高查询速度。当我们在查询表中某个字段的值时（如 WHERE gender='male'），MySQL 检索索引而不是整个表来找到符合条件的行，从而大大减少了需要扫描的数据行数。如果没有索引，则必须扫描整个表进行匹配，这样将会导致查询速度非常慢。

- 另一方面，索引可以帮助 MySQL 优化排序和分组操作。在使用 ORDER BY 或 GROUP BY 语句时，如果使用了索引，则 MySQL 可以根据索引的排序规则直接对结果进行排序或分组，避免了全表扫描。



### 3. 页(Page)

在Mysql中的InnoDB 存储引擎中，Page 以一定大小块为单位来组织和管理数据。

遵从：==先描述，后组织==。



每个 Page 包含页头、页体和页尾三部分：

1. 页头（Page Header）：包含了一些元数据信息，如页号、页类型、页校验和等。这些信息可以帮助存储引擎快速地定位到指定的 Page，并确保 Page 的完整性和一致性。
2. 页体（Page Body）：包含了这个 Page 所存储的数据。对于 InnoDB 存储引擎而言，每个 Page 中可以存储多个行，而每个行的大小取决于这个行所属的表的结构。
3. 页尾（Page Footer）：包含了一些描述这个 Page 的元数据信息，比如记录了数据在页上的排列方式、页中包含的数据记录数目等。这些信息可以帮助存储引擎快速访问和管理 Page。

如图所示：

![image-20230505213859271](./7.%20%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C.assets/image-20230505213859271.png)

### 4. 页目录

接着引入**页目录**：

除了页头、页体和页尾等部分外，还包含了一个称为“页目录”的结构，用于记录Page中的每条记录的位置和相关信息。

如图所示，在一个Page内部，我们引入了页目录。比如，我们要查找id=4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，提高了效率。  

![image-20230505221120460](./7.%20%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C.assets/image-20230505221120460.png)

如图所示，在一个Page内部，我们引入了目录。比如，我们要查找id=4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，提高了效率。  

### 5. 目录页

再引入**目录页**：

使用目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。有数据，就可通过比较，找到该访问那个Page，进而通过指针，找到下一个Page。

其实**目录页的本质也是页，普通页中存的数据是用户数据，而目录页中存的数据是普通页的地址。**

![image-20230507212826105](./7.%20%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C.assets/image-20230507212826105.png)

查找更为快速  →  大大减少了IO次数



### 6. B+树

不难发现，在InnoDB存储引擎中，所有的索引都是以B+树的结构组织的。而B+树的每一个节点都对应着一个目录页

**小结：**

1. B+树的叶子节点存储着数据行的信息，而内部分支节点则存储着指向其它页的指针。
2. 目录页是用于存储B+树节点的数据页，其中包括分支节点和叶子节点。
3. 每个目录页都有自己的页目录，页目录中记录了该目录页中所有索引项的信息，包括键值、页号等等。
4. 所有的目录页都会被管理在InnoDB存储引擎中的页目录中，页目录不仅记录了所有目录页的信息，还记录了表空间的相关信息。



**为何不使用其他数据结构，而使用B+树？**

1. B+树具有良好的平衡性

B+树是一种多路搜索树，它**能够保持所有叶子节点位于同一层，并且所有节点的深度都相等**。这样做可以确保在没有任何热点数据的情况下，每一次查找都可以获得近似的访问时间。

2. B+树具有优秀的空间利用率

在很多数据库系统中，如Hash表、二叉搜索树等，它们可能会引入大量碎片空间，导致存储空间的浪费和数据访问的不稳定性。而B+树则不存在这个问题，因为B+树每个节点都可以存储多个键值，从而**避免了碎片空间的出现**。

3. B+树具有更快的查找速度

在B+树中查找一个关键字时，只需要顺着树上的指针一步步走下去即可。由于B+树的分支因子通常较大（即高度总是不高），所以在查找时，**需要访问的节点数量较少，系统与硬盘的IO Page交互也少**。而AVL或红黑树虽然是平衡或者近似平衡，但是毕竟是二叉结构，相比较多阶B+，意味着树整体过高，需要访问的节点数量多。

注：Hash表，由于其内部不具备排序性，因此查找时虽然是 O(1) ，但对于范围查找就显得无能为力了。（MySQL中有支持hash的存储引擎）



### 7. 聚簇索引 和 非聚簇索引

MySQL中的聚簇索引和非聚簇索引是两种主要的索引类型，它们在数据存储和查询过程中扮演了不同的角色。

1. **聚簇索引**

聚簇索引（Clustered Index）是一种按照表中某列（常见为主键）的值来组织数据存储的一种索引方式。具有聚簇索引的表在物理上与索引密切相关，数据行的顺序与索引的顺序一致。在聚簇索引中，每个表只能拥有一个聚簇索引，它可以提高查询效率和IO性能，但相应的写入性能会比较差。

`InnoDB`是聚簇索引：`InnoDB` 将索引和数据放在一起。

图中为辅助索引，主键索引略

可以看到， InnoDB 的非主键索引中叶子节点并没有数据，而只有对应记录的key值。

通过辅助（普通）索引，找到目标记录，需要两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。这种过程，就叫做回表查询

![image-20230507220844930](./7.%20%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C.assets/image-20230507220844930.png)



2. **非聚簇索引**

非聚簇索引（Non-Clustered Index）是一种将索引值映射到对应的数据行的索引结构。在非聚簇索引中，为表中的多个列创建的索引都是非聚簇索引。与聚簇索引不同的是，表中可以同时存在多个非聚簇索引，并且每个非聚簇索引在底层是单独存储的。相比聚簇索引，非聚簇索引能够提供更好的写入性能，但在查询过程中可能需要进行较多的IO操作。

`MyISAM`是非聚簇索引：`InnoDB`的用户数据与索引数据分离。

如图， MyISAM 最大的特点就是叶子节点没有数据，只有对应数据的地址。

而对于 MyISAM ,建立辅助（普通）索引和主键索引没有差别，无非就是主键不能重复，而非主键可重复

![image-20230507220212146](C:\Users\陈鑫越\AppData\Roaming\Typora\typora-user-images\image-20230507220212146.png)



### 8. 索引操作 ★★★

#### 1. 创建

##### 1.1 主键索引

1. 在创建表语句末尾定义主键：

```sql
CREATE TABLE students (
  id INT(11) NOT NULL,
  name VARCHAR(50) NOT NULL,
  age INT(11) NOT NULL,
  PRIMARY KEY (id)
)
# 上述语句创建了名为students的表，并定义了id列作为主键。
```

2. 在在创建表的时候，直接在字段名后指定 primary key：

```sql
CREATE TABLE students (
  id INT(11) NOT NULL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  age INT(11) NOT NULL
);
# 与 1 相同
```

3. 使用ALTER TABLE语句中添加主键：

```sql
ALTER TABLE students ADD PRIMARY KEY (id);
# 上述语句在students表中添加了id列作为主键，需要表已经存在。
```

主键索引的**特点**：

- 一个表中，最多有一个主键索引，当然可以使符合主键

- 主键索引的效率高（主键不可重复）

- 创建主键索引的列，它的值不能为null，且不能重复

- 主键索引的列基本上是int



##### 1.2 唯一键索引

1. 在创建表语句末尾定义唯一键：

```sql
CREATE TABLE students (
  id INT(11) NOT NULL,
  name VARCHAR(50) NOT NULL,
  age INT(11) NOT NULL,
  UNIQUE (name)
);
# 上述语句创建了名为students的表，并定义了id列作为唯一键。
```

2. 在在创建表的时候，直接在字段名后指定 unique ：

```sql
CREATE TABLE students (
  id INT(11) NOT NULL UNIQUE,
  name VARCHAR(50) NOT NULL,
  age INT(11) NOT NULL
);
# 与 1 相同
```

3. 使用ALTER TABLE语句中添加主键：

```sql
ALTER TABLE students ADD UNIQUE (id);
# 上述语句在students表中添加了id列作为唯一键，需要表已经存在。
```

唯一索引的**特点**：

- 一个表中，可以有多个唯一索引

- 查询效率高

- 如果在某一列建立唯一索引，必须保证这列不能有重复数据

- 如果一个唯一索引上指定not null，等价于主键索引



##### 1.3 普通索引

1. 在创建表语句末尾定义普通索引：

```sql
CREATE TABLE students (
  id INT(11) NOT NULL,
  name VARCHAR(50) NOT NULL,
  age INT(11) NOT NULL,
  INDEX name_index (name)
);
# 上述语句创建了名为students的表，并定义了一个名为name_index的索引，即name列可以通过该索引进行查找。
```

2. 使用ALTER TABLE语句中添加索引：

```sql
ALTER TABLE students ADD INDEX name_index (name);
# 上述语句在students表的name列上创建了一个名为name_index的索引，需要表已经存在。
```

3. 使用CREATE INDEX语句创建索引：

```sql
CREATE INDEX name_index ON students (name);
# 与 2 相同
```

普通索引的**特点**：

- 一个表中可以有多个普通索引，普通索引在实际开发中用的比较多

- 如果某列需要创建索引，但是该列有重复的值，那么我们就应该使用普通索引



##### 1.4 全文索引

当对文章字段或有大量文字的字段进行检索时，会使用到全文索引。

MySQL提供全文索引机制，但是有要求，要求表的存储引擎必须是MyISAM，而且默认的全文索引支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx的中文版(coreseek)。

创建语句：

```sql
CREATE TABLE articles (
  id INT(11) NOT NULL,
  title VARCHAR(200) NOT NULL,
  content TEXT,
  FULLTEXT(title, content)
);
# 上述语句创建了一个名为articles的表，并定义了一个FULLTEXT索引。FULLTEXT索引包括title和content两列。
# 其他创建方法与普通索引类似。
```

全文索引的**特点**：

- 全文索引只能用于CHAR、VARCHAR和TEXT类型的列。
- 不支持短词（默认为4个字符或更少）和停用词（即常见词汇，如“the”、“and”等）。
- 不支持通配符匹配，只能进行模糊匹配。



#### 2. 查询

第一种方法：`show keys from table_name\G;`

第二种方法：`show index from table_name;`

第三种方法（信息比较简略）： `desc table_name;`

例如

```SQL
SHOW KEYS FROM students\G
# 查询结果类似如下所示：
*************************** 1. row ***************************
     Table: students					<= 表名
Non_unique: 0							<= 0表示唯一索引
  Key_name: PRIMARY						<= 主键索引
  Seq_in_index: 1
 Column_name: id						<= 索引在哪列
   Collation: A
 Cardinality: 147
    Sub_part: NULL
      Packed: NULL
        Null: 
  Index_type: BTREE						<= 以二叉树形式的索引
     Comment: 
*************************** 2. row ***************************
     Table: students
Non_unique: 1
  Key_name: name_index					<= 普通索引,名字为name_index
  Seq_in_index: 1
 Column_name: name
   Collation: A
 Cardinality: 147
    Sub_part: NULL
      Packed: NULL
        Null: YES
  Index_type: BTREE
     Comment: 
```

#### 3. 删除

删除主键索引： `alter table table_name drop primary key;`

其他索引的删除：` alter table table_name drop index Key_name;`

第三种方法方法：`drop index Key_name on table_name;`

例如

```sql
alter table students drop index iname_index;
```

### 9. 索引创建原则

1. 比较频繁作为查询条件的字段应该创建索引

2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
3. 更新非常频繁的字段不适合作创建索引
4. 不会出现在where子句中的字段不该创建索引

因为创建不当或者过多的索引，反而会影响数据库的性能！！！

### 10. 索引匹配原则

- 最左前缀原则：查询条件必须从左侧起始位置开始匹配

- 覆盖索引原则：在查询语句中使用的字段都包含在该索引中，不需要再访问数据表。